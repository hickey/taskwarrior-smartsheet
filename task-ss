#!/usr/bin/env python

import os,sys,re
import argparse
import logging
import json

from taskw import TaskWarrior
from smartsheet import *
from datetime import datetime
from dateutil.parser import parse as date_parse

from pprint import pprint


# Constants
CONF_FILE = os.getenv('TASK_SS_CONF') or '~/.task/smartsheet.json'


class ConfigStore:
    
    def __init__(self, conf_file=CONF_FILE):
        """ConfigStore(conf_file=CONF_FILE): object
        Read in the configuration file for locating API keys to connect to the
        Smartsheet API. The config file location can be controlled externally 
        by setting the environmental variable TASK_SS_CONF to the config file
        location. Environmental variables and tilde (~) can be used to specify 
        the file location. All parent directories must exist, but the file will
        be created if it does not exist."""
        
        self.config = {'key': None, 'proj': {}, }
        self.conf_file = os.path.expandvars( 
                         os.path.expanduser(conf_file))
        
        # expand conf_dir and test if we can proceed
        conf_dir = os.path.dirname(self.conf_file)
        if not os.path.exists(conf_dir):
            raise RuntimeError('Parent directory does not exist: ', conf_dir)
        elif not os.path.isdir(conf_dir):
            raise RuntimeError('Parent is not a directory: ', conf_dir)
        
        # Stream in the config file if it exists
        self._load_config(self.conf_file)
    
    
    def add_project(self, name, sheet, key=None, col_defs=None):
        record = { 'id': sheet, 'name': name, 'cols': col_defs }
        if key:
            record['key'] = key
        self._set('proj', sheet, record)
        
    
    def set_default_key(self, key):
        """set_default_key(key)
        Save a default key that can be used when a key has not been specified
        on a sheet."""
        self.config['key'] = key
        
        
    def default_key(self):
        if self.config['key']:
            return self.config['key']
        else:
            raise RuntimeError('Default API key not defined') 

    def save(self):
        """save()
        Take all existing keys in the Keystore object to the config file."""

        self._save_config()
        
        
    def projects(self):
        for item in self.config['proj'].keys():
            record = self.project_settings(item)
            yield record
 
 
    def project_settings(self, id):
        record = self.config['proj'][id]
        if not record.has_key('key'):
            record['key'] = self.default_key()
        return record
 
    def _set(self, type, key, val):
        self.config[type][key] = val
        
    def _get(self, type, key):
        return self.config[type][key]
        
    def _del(self, type, key):
        if self.config[type].has_key(key):
            self.config[type][key].delete
    
    def _load_config(self, conf_file):
        if os.path.exists(conf_file):
            with open(conf_file, 'r') as fh:
                try:
                    self.config = json.load(fh)
                except ValueError:
                    print "Config file corrupted. Clearing config values"


    def _save_config(self):
        with open(self.conf_file, 'w') as fh:
            json.dump(self.config, fh)


class Field:
    def __init__(self, value):
        if value.__class__ == str:
            self.value = value
        elif value.__class__ == int:
            self.value = str(value)
        elif value.__class__ == smartsheet.models.cell.Cell:
            self.value = value.value
        else:
            raise RuntimeError('Unknown field format: (%s)%s' % (value.__class__, value))
        
    def __str__(self):
        if self.value:
            return self.value
        else:
            return 'None'
            
        
class DateField(Field):
    
    def __init__(self, datetext):
        if datetext.__class__ == datetime:
            self.value = datetext
        elif datetext.__class__ == str or datetext.__class__ == unicode:
            if re.match(r'\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\+\d\d:\d\d)?', datetext):
                # 2016-12-24T18:43:12+00:00
                self.value = date_parse(datetext)
            else:
                raise RuntimeError('Unknown string date format: %s' % datetext)
        elif datetext.__class__ == smartsheet.models.cell.Cell:
            if datetext.value is None:
                self.value = None
            else:
                self.value = date_parse(datetext.value)
        elif datetext is None:
            self.value = None
        else:
            raise RuntimeError('Unknown date format: %s' % datetext)
            
    def __str__(self):
        return self.value.__str__()
        
           
class UuidField(Field):
    import uuid
    
    def __init__(self, uuidtext):
        if uuidtext.__class__ == uuid.UUID:
            self.value = uuidtext
        else:
            self.value = uuid.UUID(uuidtext)
             

class Task:
    
    def __init__(self, desc, **kw):
        self.description = Field(desc)
        self.tw_id = self.tw_uuid = self.ss_uuid = None
        self.scheduled = self.due = self.modified = None
        self.assignee = self.depends = self.status = None
        
        if kw.has_key('tw_id'):
            self.tw_id = Field(kw['tw_id'])
        if kw.has_key('tw_uuid'):
            self.tw_uuid = UuidField(kw['tw_uuid'])
        if kw.has_key('ss_uuid'):
            self.ss_uuid = Field(kw['ss_uuid'])
        if kw.has_key('scheduled'):
            self.scheduled = DateField(kw['scheduled'])
        if kw.has_key('due'):
            self.due = DateField(kw['due'])
        if kw.has_key('modified'):
            self.modified = DateField(kw['modified'])
        if kw.has_key('assignee'):
            self.assignee = Field(kw['assignee'])
        if kw.has_key('depends'):
            self.depends = Field(kw['depends'])
        if kw.has_key('status'):
            self.status = Field(kw['status'])

        
    def dump(self):
        print("---")
        print("(%s)%s - %s" % (self.tw_id, self.description, self.tw_uuid))
        print("\tstatus   : %s" % self.status)
        print("\tscheduled: %s" % self.scheduled)
        print("\tdue      : %s" % self.due)
        print("\tmodified : %s" % self.modified)
        print("\tss_uuid  : %s" % self.ss_uuid)
        print("\tassignee : %s" % self.assignee)
        print("\tdepends  : %s" % self.depends)
        
        
    def __repr__(self):
        return "<Task: %s>" % self.description
        
        
class SheetAPI:
    
    def __init__(self, config=None):
        
        if not config:
            raise RuntimeError('SheetsAPI needs reference to the configuration')
        self.config = config
        
        
    def list_sheets(self, filter=None):
        """list_sheets(filter=None): Dict
        Connect to the Smartsheet API and request a list of sheets for the given
        filter. If not filter is specified (empty string or None) then all
        sheets will be requested. """
    
        sheets = {}
        api = smartsheet.Smartsheet(self.config.default_key())
        for sheet in api.Sheets.list_sheets(include_all=True).data:
            match = True
            for text in filter:
                if text.startswith('!'):
                    # negative match (term found, deny match)
                    if re.search(text[1:], sheet.name, re.I):
                        match = False
                else:
                    # positive match (term found, allow match)
                    if not re.search(text, sheet.name, re.I):
                        match = False
                    
            if match:
                sheets[sheet.id] = sheet.name

        return sheets


    def add_project(self, name, sheet_id, key=None):
        column_info = {}
        
        # pull the sheet to get the column info
        if not key:
            key = self.config.default_key()
        api = smartsheet.Smartsheet(key)
        sheet = api.Sheets.get_sheet(sheet_id)
        
        # discover the column info 
        if sheet.gantt_enabled:
            # project sheet
            column_info = { 
                'description': self._find_col_id(sheet.columns, 'Task Name'),
                'scheduled': self._find_col_id(sheet.columns, 'Start'),
                'due': self._find_col_id(sheet.columns, 'Finish'),
                'depends': self._find_col_id(sheet.columns, 'Predecessors'),
                'assignee': self._find_col_id(sheet.columns, 'Assigned To'),
                'done': None,
                'status': self._find_col_id(sheet.columns, 'Status')
            }
        
        else:
            # task list sheet
            column_info = { 
                'description': self._find_col_id(sheet.columns, 'Task Name'),
                'scheduled': None,
                'due': self._find_col_id(sheet.columns, 'Due Date'),
                'depends': None,
                'assignee': self._find_col_id(sheet.columns, 'Assigned To'),
                'done': self._find_col_id(sheet.columns, 'Done'),
                'status': self._find_col_id(sheet.columns, 'Status')
            }
        
        self.config.add_project(name, sheet_id, key, column_info)
        
        
    def gather_tasks(self):
        
        tasks = []
    
        
        for entry in self.config.projects():
            # create an api connection to retreive sheet
            api = smartsheet.Smartsheet(entry['key'])
            
            # retrieve sheet
            sheet = api.Sheets.get_sheet(entry['id'])
            
            # walk through rows
            row_count = len(sheet.rows) - 1
            for row_num in range(row_count):
                task_data = {}
                row_data = sheet.rows[row_num]
                
                # Is this row a heading?
                if sheet.rows[row_num+1].parent_id == row_data.id:
                    continue
                
                task = Task(row_data.get_column(entry['cols']['description']),
                            ss_uuid='%s::%s' % (sheet.id, row_data.id),
                            scheduled=row_data.get_column(entry['cols']['scheduled']),
                            due=row_data.get_column(entry['cols']['due']),
                            assignee=row_data.get_column(entry['cols']['assignee']),
                            status=row_data.get_column(entry['cols']['status']),
                            modified=row_data.modified_at)
                #task.dump()
                
                # save task information
                tasks.append(task)
            
        return tasks


    def merge(self, tasks):
        """merge(tasks)
        Take an array of Task objects and apply them to the specified 
        Smartsheet sheets. """
        
        processed = []
        
        # Gather a list of sheet_ids involved
        sheet_ids = map(lambda t: (t['ss_uuid'].split('::'))[0], tasks)
        
        # Consolidate the updates according to the sheet that they are on
        for sheet_id in sheet_ids:
            # Each sheet may use a different API key, so we create a
            # new API connection for each sheet
            proj_settings = self.config.project_settings(sheet_id)
            api = smartsheet.Smartsheet(proj_settings['key'])
            row_updates = []
            
            # Filter out the tasks for a specific sheet
            for task in filter(lambda t: t['ss_uuid'].startswith(sheet_id), tasks):
                # Retrive the row to recieve the updates
                row_id = (task['ss_uuid'].split('::'))[1]
                row_data = api.Sheets.get_row(sheet_id, row_id)
                changed = False
                
                # Update description
                col_id = proj_settings['cols']['description']
                if task.description != row_data.get_column(col_id):
                    row_data.set_column(col_id, task.description)
                    changed = True
                    
                # Update start date, only on project sheets
                if proj_settings['cols'].has_key('scheduled'):
                    col_id = proj_settings['cols']['scheduled']
                    if task.scheduled != row_data.get_column(col_id):
                        row_data.set_column(col_id, task.scheduled)
                        changed = True
                
                # Update finish date
                col_id = proj_settings['cols']['due']
                if task.due != row_data.get_column(col_id):
                    row_data.set_column(col_id, task.due)
                    changed = True
                    
                # Update status
                if proj_settings['cols'].has_key('done'):
                    col_id = proj_settings['cols']['done']
                    if task.status != row_data.get_column(col_id):
                        row_data.set_column(col_id, task.status)
                        changed = True
                if proj_settings['cols'].has_key('status'):
                    col_id = proj_settings['cols']['status']
                    if task.status != row_data.get_column(col_id):
                        row_data.set_column(col_id, task.status)
                        changed = True
                
                if changed:
                    processed.append(task)
                    row_updates.append(row_data)
                    
            # Update the rows on the sheet if any have changed
            api.Sheets.update_rows(sheet_id, row_updates)
            
        return processed


    def _find_col_id(self, col_def, title):
        for cdef in col_def:
            if cdef.title == title:
                return cdef.id
        return None



class Warrior:
    
    def __init__(self, config):
        self.config = config
        self.tw = TaskWarrior(marshal=True)
        tw_config = self.tw.load_config()
        if not tw_config['uda'].has_key('ss_uuid'):
            raise RuntimeError('ss_uuid UDA not defined')
            
        
    def gather_tasks(self):
        
        tw_tasks = self.tw.load_tasks()
        
        completed = filter(lambda x: x.has_key('ss_uuid'), tw_tasks['completed'])
        pending = filter(lambda x: x.has_key('ss_uuid'), tw_tasks['pending'])
        smartsheet_tasks = completed + pending
        
        # Normalize all the Smartsheet tasks
        norm_tasks = []
        for ss_task in smartsheet_tasks:
            
            task = Task(ss_task['description'], tw_uuid=ss_task['uuid'],
                        tw_id=ss_task['id'], ss_uuid=ss_task['ss_uuid'],
                        scheduled=ss_task['scheduled'], due=ss_task['due'],
                        status=ss_task['status'], modified=ss_task['modified'])
            task.debug()
            norm_tasks.append(task)
            
        return norm_tasks
        

if __name__ == '__main__':
    
    # Proceess command line args
    parser = argparse.ArgumentParser(description='Taskwarrior to Smartsheet Sync')

    parser.add_argument('--list', '-l', default=None, type=str, nargs='*',
                        metavar='SEARCH_TEXT', 
                        help='List available Smartsheets')
    parser.add_argument('--sheet', '-s', default=None, type=int, metavar='ID',
                        help='Smartsheet ID to setup a sync for')
    parser.add_argument('--key', '-k', default=None, type=str, 
                        metavar='API_KEY',
                        help='Specify API key to access sheets')
    parser.add_argument('--project', '-P', default=None, type=str,
                        metavar='NAME',
                        help='Taskwarrior project to associate with sheet')
    parser.add_argument('--default-key', '-K', default=None, type=str,
                        metavar='API_KEY',
                        help='Set default Smartsheet API key')
    parser.add_argument('--config', '-f', default=CONF_FILE, type=str, 
                        metavar='FILE',
                        help='Read specified config file for API keys')
    parser.add_argument('command', type=str, nargs='?',
                        choices=['add', 'delete', 'modify', 'sync', 'info'])
    
    
    args = parser.parse_args()
    
    
    #logging.basicConfig()
    #logging.getLogger().setLevel(logging.DEBUG)
    #requests_log = logging.getLogger("requests.packages.urllib3")
    #requests_log.setLevel(logging.DEBUG)
    #requests_log.propagate = True
    
    
    # load the configs for connecting to Smartsheet API
    config = ConfigStore(args.config)
    try:
        if config.default_key():
            api = SheetAPI(config)
    except RuntimeError:
        if not args.default_key:
            print('Default API key has not yet been set.')
        api = None
    
    
    ## Save a default key for future use
    if args.default_key:
        config.set_default_key(args.default_key)
        config.save()
    
    ## Display a list of sheets available to sync
    elif args.list is not None and api is not None:
        sheets = api.list_sheets(filter=args.list)
        for id,name in sheets.items():
            print('%22d : %s' % (id, name))
        
    ## Check for a command
    elif args.command:
        if args.command == 'add':
            # add needs to have sheet, proj and a key
            if not args.sheet:
                print("Sheet ID needs to be specified.")
                sys.exit(1)
            if not args.project:
                print("Project name needs to be specified.")
                sys.exit(1)
            if not args.key and not config.default_key():
                print("Need an API key to add sheet.")
                sys.exit(1)
                
            api.add_project(name=args.project, sheet_id=args.sheet, 
                               key=args.key)
            config.save()
            
        elif args.command == 'sync':
            # retrieve a list of linked tasks from TaskWarrior
            war = Warrior(config)
            tw_tasks = war.gather_tasks()
            
            # Update Smartsheet sheet
            api.merge(tw_tasks)
            
            # retrieve a list of tasks from Smartsheet
            ss_tasks = api.gather_tasks()
            
            # Update TaskWarrior tasks
            #war.merge(ss_tasks)
            
        elif args.command == 'info':
            api = smartsheet.Smartsheet(config.default_key())
            print api.Sheets.get_sheet(args.sheet)
