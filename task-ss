#!/usr/bin/env python

import os,sys,re
import argparse
import logging
import json

from taskw import TaskWarrior
from smartsheet import *
from datetime import datetime
from dateutil.parser import parse as date_parse

from pprint import pprint


# Constants
CONF_FILE = os.getenv('TASK_SS_CONF') or '~/.task/smartsheet.json'


class ConfigStore:
    
    def __init__(self, conf_file=CONF_FILE):
        """ConfigStore(conf_file=CONF_FILE): object
        Read in the configuration file for locating API keys to connect to the
        Smartsheet API. The config file location can be controlled externally 
        by setting the environmental variable TASK_SS_CONF to the config file
        location. Environmental variables and tilde (~) can be used to specify 
        the file location. All parent directories must exist, but the file will
        be created if it does not exist."""
        
        self.config = {'key': None, 'proj': {}, }
        self.conf_file = os.path.expandvars( 
                         os.path.expanduser(conf_file))
        
        # expand conf_dir and test if we can proceed
        conf_dir = os.path.dirname(self.conf_file)
        if not os.path.exists(conf_dir):
            raise RuntimeError('Parent directory does not exist: ', conf_dir)
        elif not os.path.isdir(conf_dir):
            raise RuntimeError('Parent is not a directory: ', conf_dir)
        
        # Stream in the config file if it exists
        self._load_config(self.conf_file)
    
    
    def add_project(self, name, sheet, key=None, col_defs=None):
        record = { 'id': sheet, 'name': name, 'cols': col_defs }
        if key:
            record['key'] = key
        self._set('proj', sheet, record)
        
    
    def set_default_key(self, key):
        """set_default_key(key)
        Save a default key that can be used when a key has not been specified
        on a sheet."""
        self.config['key'] = key
        
        
    def default_key(self):
        if self.config['key']:
            return self.config['key']
        else:
            raise RuntimeError('Default API key not defined') 

    def save(self):
        """save()
        Take all existing keys in the Keystore object to the config file."""

        self._save_config()
        
        
    def projects(self):
        for item in self.config['proj'].keys():
            record = self.project_settings(item)
            yield record
 
 
    def project_settings(self, id):
        record = self.config['proj'][id]
        if not record.has_key('key'):
            record['key'] = self.default_key()
        return record
 
    def _set(self, type, key, val):
        self.config[type][key] = val
        
    def _get(self, type, key):
        return self.config[type][key]
        
    def _del(self, type, key):
        if self.config[type].has_key(key):
            self.config[type][key].delete
    
    def _load_config(self, conf_file):
        if os.path.exists(conf_file):
            with open(conf_file, 'r') as fh:
                try:
                    self.config = json.load(fh)
                except ValueError:
                    print "Config file corrupted. Clearing config values"


    def _save_config(self):
        print "config = %s" % self.config
        with open(self.conf_file, 'w') as fh:
            json.dump(self.config, fh)


class Field:
    def __init__(self, value):
        self.value = value
        
    def __repr__(self):
        return self.value
        
        
class DateField(Field):
    
    def __init__(self, datetext):
        if datetext.__class__ == datetime:
            self.value = datetext
        elif datetext.__class__ == str or datetext.__class__ == unicode:
            if re.match(r'\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\+\d\d:\d\d)?', datetext):
                # 2016-12-24T18:43:12+00:00
                self.value = date_parse(datetext)
            else:
                raise RuntimeError('Unknown string date format: %s' % datetext)
        elif datetext is None:
            self.value = None
        else:
            raise RuntimeError('Unknown date format: %s' % datetext)
           
class UuidField(Field):
    import uuid
    
    def __init__(self, uuidtext):
        if uuidtext.__class__ == uuid.UUID:
            self.value = uuidtext
        else:
            self.value = uuid.UUID(uuidtext)
             

class Task:
    
    def __init__(self, desc, **kw):
        self.description = Field(desc)
        
        if kw.has_key('tw_id'):
            self.tw_id = Field(kw['tw_id'])
        if kw.has_key('tw_uuid'):
            self.tw_uuid = UuidField(kw['tw_uuid'])
        if kw.has_key('ss_uuid'):
            self.ss_uuid = Field(kw['ss_uuid'])
        if kw.has_key('scheduled'):
            self.scheduled = DateField(kw['scheduled'])
        if kw.has_key('due'):
            self.due = DateField(kw['due'])
        if kw.has_key('modified'):
            self.modified = DateField(kw['modified'])
        if kw.has_key('assignee'):
            self.assignee = Field(kw['assignee'])
        if kw.has_key('depends'):
            self.depends = Field(kw['depends'])
        if kw.has_key('status'):
            self.status = Field(kw['status'])

        
    def __repr__(self):
        return "<Task: %s>" % self.description
        
        
class SheetAPI:
    
    def __init__(self, config=None):
        
        if not config:
            raise RuntimeError('SheetsAPI needs reference to the configuration')
        self.config = config
        
        
    def list_sheets(self, filter=None):
        """list_sheets(filter=None): Dict
        Connect to the Smartsheet API and request a list of sheets for the given
        filter. If not filter is specified (empty string or None) then all
        sheets will be requested. """
    
        sheets = {}
        api = smartsheet.Smartsheet(self.config.default_key())
        for sheet in api.Sheets.list_sheets(include_all=True).data:
            match = True
            for text in filter:
                if text.startswith('!'):
                    # negative match (term found, deny match)
                    if re.search(text[1:], sheet.name, re.I):
                        match = False
                else:
                    # positive match (term found, allow match)
                    if not re.search(text, sheet.name, re.I):
                        match = False
                    
            if match:
                sheets[sheet.id] = sheet.name

        return sheets


    def add_project(self, name, sheet_id, key=None):
        column_info = {}
        
        # pull the sheet to get the column info
        if not key:
            key = self.config.default_key()
        api = smartsheet.Smartsheet(key)
        sheet = api.Sheets.get_sheet(sheet_id)
        
        # discover the column info 
        if sheet.gantt_enabled:
            # project sheet
            column_info = { 
                'description': self._find_col_id(sheet.columns, 'Task Name'),
                'scheduled': self._find_col_id(sheet.columns, 'Start'),
                'due': self._find_col_id(sheet.columns, 'Finish'),
                'depends': self._find_col_id(sheet.columns, 'Predecessors'),
                'assignee': self._find_col_id(sheet.columns, 'Assigned To'),
                'done': None,
                'status': self._find_col_id(sheet.columns, 'Status')
            }
        
        else:
            # task list sheet
            column_info = { 
                'description': self._find_col_id(sheet.columns, 'Task Name'),
                'scheduled': None,
                'due': self._find_col_id(sheet.columns, 'Due Date'),
                'depends': None,
                'assignee': self._find_col_id(sheet.columns, 'Assigned To'),
                'done': self._find_col_id(sheet.columns, 'Done'),
                'status': self._find_col_id(sheet.columns, 'Status')
            }
        
        self.config.add_project(name, sheet_id, key, column_info)
        
        
    def gather_tasks(self):
        
        tasks = []
    
        
        for entry in self.config.projects():
            # create an api connection to retreive sheet
            api = smartsheet.Smartsheet(entry['key'])
            
            # retrieve sheet
            sheet = api.Sheets.get_sheet(entry['id'])
            
            # walk through rows
            row_count = len(sheet.rows) - 1
            for row_num in range(row_count):
                task_data = {}
                row_data = sheet.rows[row_num]
                
                # Is this row a heading?
                if sheet.rows[row_num+1].parent_id == row_data.id:
                    continue
                
                task = Task(self._extract(row_data, entry['cols']['description']),
                            tw_id=row_data.id,
                            scheduled=self._extract(row_data, entry['cols']['scheduled']),
                            due=self._extract(row_data, entry['cols']['due']),
                            assignee=self._extract(row_data, entry['cols']['assignee']),
                            status=self._extract(row_data, entry['cols']['status']),
                            modified=row_data.modified_at)

                # save task information
                tasks.append(task)
            
        return tasks
        
            
        
    def _find_col_id(self, col_def, title):
        for cdef in col_def:
            if cdef.title == title:
                return cdef.id
        return None

    def _extract(self, data, col_id):
        for cell in data.cells:
            if cell.column_id == col_id:
                return cell.value
        return None
        
        

class Warrior:
    
    def __init__(self, config):
        self.config = config
        self.tw = TaskWarrior(marshal=True)
        tw_config = self.tw.load_config()
        if not tw_config['uda'].has_key('ss_uuid'):
            raise RuntimeError('ss_uuid UDA not defined')
            
        
    def gather_tasks(self):
        
        tasks = self.tw.load_tasks()
        
        completed = filter(lambda x: x.has_key('ss_uuid'), tasks['completed'])
        pending = filter(lambda x: x.has_key('ss_uuid'), tasks['pending'])
        ss_tasks = completed + pending
        
        # Normalize all the Smartsheet tasks
        norm_task = []
        for task in ss_tasks:
            
            intermediate = { 'id': task['ss_uuid'],
                             'description': task['description'],
                             'scheduled': task['scheduled'], 
                             'due': task['due'],
                             
            
        }
            
            task_data['id'] = row_data.id
            
            # description
            task_data['description'] = self._extract(row_data, 
                                            entry['cols']['description'])
            # scheduled
            task_data['scheduled'] = self._extract(row_data, 
                                            entry['cols']['scheduled'])
            # due
            task_data['due'] = self._extract(row_data, 
                                            entry['cols']['due'])
            # assignee
            task_data['assignee'] = self._extract(row_data, 
                                            entry['cols']['assignee'])
            # done
            task_data['depends'] = self._extract(row_data, 
                                            entry['cols']['depends'])
            # status
            task_data['status'] = self._extract(row_data, 
                                            entry['cols']['status'])
            
            task_data['modify_at'] = row_data.modified_at
            

if __name__ == '__main__':
    
    # Proceess command line args
    parser = argparse.ArgumentParser(description='Taskwarrior to Smartsheet Sync')

    parser.add_argument('--list', '-l', default=None, type=str, nargs='*',
                        metavar='SEARCH_TEXT', 
                        help='List available Smartsheets')
    parser.add_argument('--sheet', '-s', default=None, type=int, metavar='ID',
                        help='Smartsheet ID to setup a sync for')
    parser.add_argument('--key', '-k', default=None, type=str, 
                        metavar='API_KEY',
                        help='Specify API key to access sheets')
    parser.add_argument('--project', '-P', default=None, type=str,
                        metavar='NAME',
                        help='Taskwarrior project to associate with sheet')
    parser.add_argument('--default-key', '-K', default=None, type=str,
                        metavar='API_KEY',
                        help='Set default Smartsheet API key')
    parser.add_argument('--config', '-f', default=CONF_FILE, type=str, 
                        metavar='FILE',
                        help='Read specified config file for API keys')
    parser.add_argument('command', type=str, nargs='?',
                        choices=['add', 'delete', 'modify', 'sync', 'info'])
    
    
    args = parser.parse_args()
    
    
    #logging.basicConfig()
    #logging.getLogger().setLevel(logging.DEBUG)
    #requests_log = logging.getLogger("requests.packages.urllib3")
    #requests_log.setLevel(logging.DEBUG)
    #requests_log.propagate = True
    
    
    # load the configs for connecting to Smartsheet API
    config = ConfigStore(args.config)
    try:
        if config.default_key():
            api = SheetAPI(config)
    except RuntimeError:
        if not args.default_key:
            print('Default API key has not yet been set.')
        api = None
    
    
    ## Save a default key for future use
    if args.default_key:
        config.set_default_key(args.default_key)
        config.save()
    
    ## Display a list of sheets available to sync
    elif args.list is not None and api is not None:
        sheets = api.list_sheets(filter=args.list)
        for id,name in sheets.items():
            print('%22d : %s' % (id, name))
        
    ## Check for a command
    elif args.command:
        if args.command == 'add':
            # add needs to have sheet, proj and a key
            if not args.sheet:
                print("Sheet ID needs to be specified.")
                sys.exit(1)
            if not args.project:
                print("Project name needs to be specified.")
                sys.exit(1)
            if not args.key and not config.default_key():
                print("Need an API key to add sheet.")
                sys.exit(1)
                
            api.add_project(name=args.project, sheet_id=args.sheet, 
                               key=args.key)
            config.save()
            
        elif args.command == 'sync':
            # retrieve a list of tasks from Smartsheet
            ss_tasks = api.gather_tasks()

            # retrieve a list of linked tasks from TaskWarrior
            war = Warrior(config)
            tw_tasks = war.gather_tasks()
            
            
        elif args.command == 'info':
            api = smartsheet.Smartsheet(config.default_key())
            print api.Sheets.get_sheet(args.sheet)
